import { __awaiter, __extends, __generator } from "tslib";
import { ToneAudioNode } from "../../core/context/ToneAudioNode";
import { Gain } from "../../core/context/Gain";
import { assert } from "../../core/util/Debug";
import { theWindow } from "../../core/context/AudioContext";
import { optionsFromArguments } from "../../core/util/Defaults";
/**
 * This is only natively supported in Chrome and Firefox.
 * For a cross-browser shim, install (MediaStreamRecorder)[https://github.com/streamproc/MediaStreamRecorder].
 * @example
 * import { Recorder, Synth } from "tone";
 * const recorder = new Recorder();
 * const synth = new Synth().connect(recorder);
 * // start recording
 * recorder.start();
 * // generate a few notes
 * synth.triggerAttackRelease("C3", 0.5);
 * synth.triggerAttackRelease("C4", 0.5, "+1");
 * synth.triggerAttackRelease("C5", 0.5, "+2");
 * // wait for the notes to end and stop the recording
 * setTimeout(async () => {
 * 	// the recorded audio is returned as a blob
 * 	const recording = await recorder.stop();
 * 	// download the recording by creating an anchor element and blob url
 * 	const url = URL.createObjectURL(recording);
 * 	const anchor = document.createElement("a");
 * 	anchor.download = "recording.webm";
 * 	anchor.href = url;
 * 	anchor.click();
 * }, 4000);
 */
var Recorder = /** @class */ (function (_super) {
    __extends(Recorder, _super);
    function Recorder() {
        var _this = _super.call(this, optionsFromArguments(Recorder.getDefaults(), arguments, ["gain", "units"])) || this;
        _this.name = "Recorder";
        var options = optionsFromArguments(Recorder.getDefaults(), arguments, ["gain", "units"]);
        _this.input = new Gain({
            context: _this.context
        });
        assert(Recorder.supported, "Media Recorder API is not available");
        _this._stream = _this.context.createMediaStreamDestination();
        _this.input.connect(_this._stream);
        _this._recorder = new MediaRecorder(_this._stream.stream, {
            mimeType: options.mimeType
        });
        return _this;
    }
    Recorder.getDefaults = function () {
        return ToneAudioNode.getDefaults();
    };
    Object.defineProperty(Recorder.prototype, "mimeType", {
        /**
         * The mime type is the format that the audio is encoded in. For Chrome
         * that is typically webm encoded as "vorbis".
         */
        get: function () {
            return this._recorder.mimeType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recorder, "supported", {
        /**
         * Test if your platform supports the Media Recorder API. If it's not available,
         * try installing this (polyfill)[https://github.com/streamproc/MediaStreamRecorder].
         */
        get: function () {
            return theWindow !== null && Reflect.has(theWindow, "MediaRecorder");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recorder.prototype, "state", {
        /**
         * Get the playback state of the Recorder, either "started", "stopped" or "paused"
         */
        get: function () {
            if (this._recorder.state === "inactive") {
                return "stopped";
            }
            else if (this._recorder.state === "paused") {
                return "paused";
            }
            else {
                return "started";
            }
        },
        enumerable: true,
        configurable: true
    });
    Recorder.prototype.start = function () {
        assert(this.state !== "started", "Recorder is already started");
        this._recorder.start();
        return this;
    };
    Recorder.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            var dataPromise;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        assert(this.state !== "stopped", "Recorder is not started");
                        dataPromise = new Promise(function (done) {
                            _this._recorder.ondataavailable = function (e) { return done(e.data); };
                        });
                        this._recorder.stop();
                        return [4 /*yield*/, dataPromise];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Recorder.prototype.pause = function () {
        assert(this.state === "started", "Recorder must be started");
        this._recorder.pause();
        return this;
    };
    Recorder.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.input.dispose();
        this._stream.disconnect();
        return this;
    };
    return Recorder;
}(ToneAudioNode));
export { Recorder };
//# sourceMappingURL=Recorder.js.map